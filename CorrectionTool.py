#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Error Compensation Test Module
Specialized for testing and collecting mechanical arm error data
"""

import sys
import os
import cv2
import numpy as np

# Add project root directory to Python path
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from LegoGraspingSystem import LegoGraspingSystem
from utils import RobotCompensation

class ErrorCompensationTester:
    """Error Compensation Tester"""
    
    def __init__(self):
        self.system = None
        self.cap = None
    
    def initialize_system(self):
        """Initialize system (without hand-eye calibration)"""
        print("üîß Initialize system...")
        
        try:
            self.system = LegoGraspingSystem()
            
            # Initialize basic components, without hand-eye calibration
            if not self.system.initialize_system():
                print("‚ùå System initialization failed")
                return False
            
            # Check if already calibrated
            if not hasattr(self.system, 'calibration') or not self.system.calibration:
                print("‚ùå System not calibrated, please run hand-eye calibration first")
                return False
            
            print("‚úÖ System initialization completed")
            return True
            
        except Exception as e:
            print(f"‚ùå Initialization failed: {e}")
            return False
    
    def manual_error_test(self):
        """Manual error test"""
        print("\nManual error test")
        print("=" * 50)
        print("Test steps:")
        print("1. Input target position")
        print("2. Move the robot arm to the target position")
        print("3. Measure the actual position reached by the robot arm")
        print("4. Record error data")
        print("=" * 50)
        
        try:
            # Input target position
            print("\nPlease input target position:")
            target_x = float(input("Target X coordinate (mm): "))
            target_y = float(input("Target Y coordinate (mm): "))
            target_z = float(input("Target Z coordinate (mm): "))
            target_position = (target_x, target_y, target_z)
            
            print(f"\nüéØ Target position: {target_position}")
            
            # Confirm move
            confirm = input("Move the robot arm to the target position? (y/n): ")
            if confirm.lower() != 'y':
                print("‚ùå Cancel test")
                return False
            
            # Move the robot arm to the target position
            print("The robot arm is moving to the target position...")
            
            # Calculate inverse kinematics
            from utils.InverseKinematic import inverse_kinematics
            joint_angles = inverse_kinematics(target_position)
            
            if joint_angles is None:
                print("‚ùå Inverse kinematics calculation failed, position unreachable")
                return False
            
            # Apply joint compensation
            compensated_angles = RobotCompensation.data_driven_joint_compensation(*joint_angles)
            
            # Move the robot arm step by step
            if self.system and self.system.robot:
                try:
                    # Step 1: Move to safe height and open gripper
                    print("üîÑ Step 1: Move to safe height and open gripper...")
                    
                    # Calculate the position of safe height (keep x,y unchanged, set z to safe height)
                    safe_position = (target_x, target_y, RobotCompensation.SAFE_HEIGHT)
                    safe_joint_angles = inverse_kinematics(safe_position)
                    
                    if safe_joint_angles is None:
                        print("‚ùå Safe height position unreachable")
                        return False
                    
                    # Move to safe height and open gripper
                    safe_compensated_angles = RobotCompensation.data_driven_joint_compensation(*safe_joint_angles)
                    self.system.robot.move_to_angles(*safe_compensated_angles, RobotCompensation.GRIPPER_OPEN_ANGLE, RobotCompensation.MOVE_TIME)
                    print(f"‚úÖ Moved to safe height {RobotCompensation.SAFE_HEIGHT}mm, gripper opened to {RobotCompensation.GRIPPER_OPEN_ANGLE}¬∞")
                    
                    # Wait for the action to complete
                    import time
                    time.sleep(1)
                    
                    # Step 2: Move to target position
                    print("üîÑ Step 2: Move to target position...")
                    self.system.robot.move_to_angles(*compensated_angles)
                    print("‚úÖ Robot arm moved to target position")
                    
                except Exception as e:
                    print(f"‚ùå Robot arm movement failed: {e}")
                    return False
            else:
                print("‚ö†Ô∏è Robot arm not connected, simulate step-by-step movement")
                print(f"Step 1: Safe height {RobotCompensation.SAFE_HEIGHT}mm, gripper angle {RobotCompensation.GRIPPER_OPEN_ANGLE}¬∞")
                print(f"Step 2: Target position, joint angles: {compensated_angles}")
            
            # Wait for user to measure actual position
            input("\nPlease measure the actual position reached by the robot arm, then press Enter to continue...")
            
            # Input actual position
            print("\nPlease input the actual position reached by the robot arm:")
            actual_x = float(input("Actual X coordinate (mm): "))
            actual_y = float(input("Actual Y coordinate (mm): "))
            actual_z = float(input("Actual Z coordinate (mm): "))
            actual_position = (actual_x, actual_y, actual_z)
            
            # Add error data
            RobotCompensation.add_error_data(target_position, actual_position)
            
            # Calculate error
            x_error = actual_x - target_x
            y_error = actual_y - target_y
            z_error = actual_z - target_z
            
            print(f"\nüìä Error analysis:")
            print(f"Target position: {target_position}")
            print(f"Actual position: {actual_position}")
            print(f"Error: ({x_error:.2f}, {y_error:.2f}, {z_error:.2f})")
            print(f"Total error: {np.sqrt(x_error**2 + y_error**2 + z_error**2):.2f} mm")
            
            return True
            
        except ValueError:
            print("‚ùå Input format error, please enter numbers")
            return False
        except Exception as e:
            print(f"‚ùå Test failed: {e}")
            return False
    
    def camera_based_error_test(self):
        """Camera-based error test"""
        print("\nüì∑ Camera-based error test")
        print("=" * 50)
        print("Test steps:")
        print("1. Place a red Lego brick in the camera's field of view")
        print("2. Press 't' to perform detection and error test")
        print("3. Press 'v' to view the error database")
        print("4. Press 'q' to exit the test")
        print("=" * 50)
        
        if not self.system or not self.system.cap:
            print("‚ùå System not initialized or camera not opened")
            return False
        
        # Check if hand-eye calibration has been completed
        if not self.system.is_calibrated:
            print("‚ùå System not calibrated, please run hand-eye calibration first")
            print("Suggestion: Run the main system for hand-eye calibration before using this test")
            return False
        
        print("‚úÖ Start camera-based error test...")
        
        while True:
            ret, frame = self.system.cap.read()
            if not ret:
                print("‚ùå Unable to read camera frame")
                break
            
            # Create a copy of the image for display
            display_frame = frame.copy()
            
            # Detect and display the Lego brick
            lego_result = self.system.detect_red_lego(frame)
            if lego_result:
                lego_x, lego_y, lego_angle = lego_result
                # Mark the Lego brick position on the image
                cv2.circle(display_frame, (lego_x, lego_y), 10, (0, 255, 0), 2)
                cv2.putText(display_frame, f"Lego: ({lego_x}, {lego_y})", 
                           (lego_x + 15, lego_y - 15), cv2.FONT_HERSHEY_SIMPLEX, 0.6, (0, 255, 0), 2)
            
            # Display the camera frame
            cv2.imshow('Camera Error Test - Press t to test, v to view, q to quit', display_frame)
            
            key = cv2.waitKey(1) & 0xFF
            
            if key == ord('q'):
                print("Exit camera-based error test")
                break
            elif key == ord('t'):
                self.perform_camera_error_test(frame)
            elif key == ord('v'):
                RobotCompensation.print_error_database()
        
        cv2.destroyAllWindows()
        return True
    def detect_red_tape(self, frame):
        """
        Detect the red tape on the robot arm
        
        Args:
            frame: Input image frame
            
        Returns:
            Optional[Tuple[int, int, float, list]]: The center pixel coordinates, angle, and contour information of the detected red tape,
            formatted as (x, y, angle, contour_info), if not detected, return None
        """
        # Convert to HSV color space
        hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)
        
        # Define the range of red tape
        lower_red1 = np.array([0, 100, 100])
        upper_red1 = np.array([10, 255, 255])
        lower_red2 = np.array([160, 100, 100])
        upper_red2 = np.array([180, 255, 255])
        
        # Create red mask
        mask1 = cv2.inRange(hsv, lower_red1, upper_red1)
        mask2 = cv2.inRange(hsv, lower_red2, upper_red2)
        mask = mask1 + mask2
        
        # Morphological operations to remove noise
        kernel = np.ones((3, 3), np.uint8)  # Use a smaller kernel because the tape is smaller
        mask = cv2.morphologyEx(mask, cv2.MORPH_CLOSE, kernel)
        mask = cv2.morphologyEx(mask, cv2.MORPH_OPEN, kernel)
        
        # Find contours
        contours, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
        
        if contours:
            # Sort by area, find the appropriate size of the contour (tape is smaller than the Lego brick)
            sorted_contours = sorted(contours, key=cv2.contourArea, reverse=True)
            
            for contour in sorted_contours:
                area = cv2.contourArea(contour)
                
                # Tape area range: approximately 1 square centimeter, approximately 100-800 pixels in the image
                # Lego brick area is usually greater than 1000 pixels
                if 100 <= area <= 800:  # Tape area range
                    # Calculate the center point of the contour
                    M = cv2.moments(contour)
                    if M["m00"] != 0:
                        cx = int(M["m10"] / M["m00"])
                        cy = int(M["m01"] / M["m00"])
                        
                        # Calculate the angle of the tape
                        rect = cv2.minAreaRect(contour)
                        angle = rect[2]  # Get the angle
                        
                        # Angle normalization: ensure the angle is between -90 and 90 degrees
                        if angle < -45:
                            angle += 90
                        elif angle > 45:
                            angle -= 90
                        
                        # Return the detection result and contour information
                        contour_info = {
                            'contour': contour,
                            'rect': rect,
                            'area': area,
                            'center': (cx, cy)
                        }
                        
                        return (cx, cy, angle, contour_info)
        
        return None
        
    def automated_error_test(self):
        """Automated error test process"""
        print("\nü§ñ Automated error test process")
        print("=" * 50)
        print("Test steps:")
        print("1. Detect the position of the red Lego brick")
        print("2. Move the robot arm to the Lego brick position")
        print("3. Detect the position of the red tape on the robot arm")
        print("4. Calculate the error and store it in the database")
        print("=" * 50)
        
        if not self.system or not self.system.cap:
            print("‚ùå System not initialized or camera not opened")
            return False
        
        # Check if hand-eye calibration has been completed
        if not self.system.is_calibrated:
            print("‚ùå System not calibrated, please run hand-eye calibration first")
            return False
        
        print("‚úÖ Start automated error test...")
        
        while True:
            ret, frame = self.system.cap.read()
            if not ret:
                print("‚ùå Unable to read camera frame")
                break
            
            # Create a copy of the image for display
            display_frame = frame.copy()
            
            # Detect and display the Lego brick
            lego_result = self.system.detect_red_lego(frame)
            if lego_result:
                lego_x, lego_y, lego_angle = lego_result
                # Mark the Lego brick position on the image
                cv2.circle(display_frame, (lego_x, lego_y), 10, (0, 255, 0), 2)
                cv2.putText(display_frame, f"Lego: ({lego_x}, {lego_y})", 
                           (lego_x + 15, lego_y - 15), cv2.FONT_HERSHEY_SIMPLEX, 0.6, (0, 255, 0), 2)
            
            # Detect and display the tape
            tape_result = self.detect_red_tape(frame)
            if tape_result:
                tape_x, tape_y, tape_angle, contour_info = tape_result
                # Mark the tape position on the image
                cv2.circle(display_frame, (tape_x, tape_y), 8, (255, 0, 0), 2)
                cv2.putText(display_frame, f"Tape: ({tape_x}, {tape_y})", 
                           (tape_x + 15, tape_y - 15), cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255, 0, 0), 2)
            
            # Display the camera frame
            cv2.imshow('Automated Error Test - Press t to test, q to quit', display_frame)
            
            key = cv2.waitKey(1) & 0xFF
            
            if key == ord('q'):
                self.system.robot.move_to_home()
                print("Exit automated error test")
                break
            elif key == ord('t'):
                self.perform_automated_error_test(frame)
        
        cv2.destroyAllWindows()
        return True

    def perform_automated_error_test(self, frame):
        """Perform automated error test"""
        print("\nüîç Perform automated error test...")
        
        # Check if the system is initialized
        if not self.system:
            print("‚ùå System not initialized")
            return False
        
        # Step 1: Detect the red Lego brick
        print("üîç Step 1: Detect the red Lego brick...")
        lego_result = self.system.detect_red_lego(frame)
        
        if not lego_result:
            print("‚ùå No red Lego brick detected")
            return False
        
        lego_x, lego_y, lego_angle = lego_result
        lego_pixel_coord = (lego_x, lego_y)
        
        print(f"Detected Lego brick position: {lego_pixel_coord}")
        print(f"Detected Lego brick angle: {lego_angle:.1f}¬∞")
        
        # Calculate the physical coordinates of the Lego brick
        if not self.system.calibration:
            print("‚ùå System not calibrated")
            return False
        
        try:
            lego_physical_coord = self.system.calibration.pixel_to_physical(lego_pixel_coord)
            if not lego_physical_coord:
                print("‚ùå Unable to calculate the physical coordinates of the Lego brick")
                return False
        except ValueError as e:
            print(f"‚ùå Calibration error: {e}")
            return False
        
        # Â∫îÁî®Âü∫Á°ÄË°•ÂÅøÂæóÂà∞ÁõÆÊ†á‰ΩçÁΩÆ
        target_coord = self.system.calculate_grasp_position(lego_pixel_coord)
        if not target_coord:
            print("‚ùå Êó†Ê≥ïËÆ°ÁÆóÁõÆÊ†áÂùêÊ†á")
            return False
        
        print(f"ÁßØÊú®Áâ©ÁêÜÂùêÊ†á: {lego_physical_coord}")
        print(f"ÁõÆÊ†áÁßªÂä®ÂùêÊ†á: {target_coord}")
        
        # Á°ÆËÆ§ÁßªÂä®
        confirm = input("ÊòØÂê¶ËÆ©Êú∫Ê¢∞ËáÇÁßªÂä®Âà∞ÁßØÊú®‰ΩçÁΩÆÔºü(y/n): ")
        if confirm.lower() == 'n':
            print("‚ùå ÂèñÊ∂àÊµãËØï")
            return False
        
        # Á¨¨‰∫åÊ≠•ÔºöÊú∫Ê¢∞ËáÇÁßªÂä®Âà∞ÁõÆÊ†á‰ΩçÁΩÆ
        print("ü§ñ Á¨¨‰∫åÊ≠•ÔºöÊú∫Ê¢∞ËáÇÁßªÂä®Âà∞ÁõÆÊ†á‰ΩçÁΩÆ...")
        
        try:
            # ËÆ°ÁÆóÈÄÜËøêÂä®Â≠¶
            from utils.InverseKinematic import inverse_kinematics
            joint_angles = inverse_kinematics(target_coord)
            
            if joint_angles is None:
                print("‚ùå ÈÄÜËøêÂä®Â≠¶ËÆ°ÁÆóÂ§±Ë¥•Ôºå‰ΩçÁΩÆ‰∏çÂèØËææ")
                return False
            
            # Â∫îÁî®ÂÖ≥ËäÇË°•ÂÅø
            compensated_angles = RobotCompensation.data_driven_joint_compensation(*joint_angles)
            
            # ÁßªÂä®Âà∞ÁõÆÊ†á‰ΩçÁΩÆ
            self.system.robot.move_to_angles(*compensated_angles, RobotCompensation.GRIPPER_OPEN_ANGLE, RobotCompensation.MOVE_TIME)
            print("‚úÖ Êú∫Ê¢∞ËáÇÁßªÂä®ÂÆåÊàê")
        except Exception as e:
            print(f"‚ùå Êú∫Ê¢∞ËáÇÁßªÂä®Â§±Ë¥•: {e}")
            return False
        
        # Á≠âÂæÖÊú∫Ê¢∞ËáÇÁ®≥ÂÆö
        print("‚è≥ Á≠âÂæÖÊú∫Ê¢∞ËáÇÁ®≥ÂÆö...")
        import time
        time.sleep(2)
        
        # Á¨¨‰∏âÊ≠•ÔºöÊ£ÄÊµãÁ∫¢Ëâ≤ËÉ∂Â∏¶
        print("üîç Á¨¨‰∏âÊ≠•ÔºöÊ£ÄÊµãÊú∫Ê¢∞ËáÇ‰∏äÁöÑÁ∫¢Ëâ≤ËÉ∂Â∏¶...")
        
        tape_result = None
        max_attempts = 5  # ÊúÄÂ§ßÂ∞ùËØïÊ¨°Êï∞
        
        for attempt in range(max_attempts):
            print(f"\nüîÑ Á¨¨ {attempt + 1} Ê¨°Â∞ùËØïÊ£ÄÊµãËÉ∂Â∏¶...")
            
            # ÈáçÊñ∞ÊãçÊëÑÂõæÂÉè
            if not self.system.cap:
                print("‚ùå ÊëÑÂÉèÂ§¥Êú™ÊâìÂºÄ")
                return False
                
            ret, new_frame = self.system.cap.read()
            if not ret:
                print("‚ùå Êó†Ê≥ïËØªÂèñÊñ∞ÁöÑÊëÑÂÉèÂ§¥ÁîªÈù¢")
                return False
            
            # Ê£ÄÊµãÁ∫¢Ëâ≤ËÉ∂Â∏¶
            tape_result = self.detect_red_tape(new_frame)
            
            if not tape_result:
                print("‚ùå Êú™Ê£ÄÊµãÂà∞Á∫¢Ëâ≤ËÉ∂Â∏¶")
                if attempt < max_attempts - 1:
                    retry = input("ÊòØÂê¶ÈáçÊñ∞Ê£ÄÊµãÔºü(y/n): ")
                    if retry.lower() == 'n':
                        print("‚ùå Áî®Êà∑ÂèñÊ∂àÊ£ÄÊµã")
                        self.system.robot.move_to_home()
                        return False
                    continue
                else:
                    print("‚ùå ËææÂà∞ÊúÄÂ§ßÂ∞ùËØïÊ¨°Êï∞ÔºåÊ£ÄÊµãÂ§±Ë¥•")
                    print("ËØ∑Á°Æ‰øùÊú∫Ê¢∞ËáÇ‰∏äË¥¥ÊúâÁ∫¢Ëâ≤ËÉ∂Â∏¶Ê†áËÆ∞")
                    self.system.robot.move_to_home()
                    return False
            
            tape_x, tape_y, tape_angle, contour_info = tape_result
            tape_pixel_coord = (tape_x, tape_y)
            
            print(f"Ê£ÄÊµãÂà∞ËÉ∂Â∏¶‰ΩçÁΩÆ: {tape_pixel_coord}")
            print(f"Ê£ÄÊµãÂà∞ËÉ∂Â∏¶ËßíÂ∫¶: {tape_angle:.1f}¬∞")
            
            # Âú®‰∏ªÁ™óÂè£ÊòæÁ§∫Ê£ÄÊµãÁªìÊûú
            display_frame = new_frame.copy()
            
            # ÁªòÂà∂ËÉ∂Â∏¶ËΩÆÂªì
            cv2.drawContours(display_frame, [contour_info['contour']], -1, (255, 0, 0), 2)
            
            # ÁªòÂà∂‰∏≠ÂøÉÁÇπ
            cv2.circle(display_frame, (tape_x, tape_y), 5, (255, 0, 0), -1)
            
            # ÁªòÂà∂ÊúÄÂ∞èÂ§ñÊé•Áü©ÂΩ¢
            box = cv2.boxPoints(contour_info['rect'])
            box = np.array(box, dtype=np.int32)
            cv2.drawContours(display_frame, [box], 0, (0, 255, 0), 2)
            
            # Ê∑ªÂä†ÊñáÊú¨‰ø°ÊÅØ
            cv2.putText(display_frame, f"Tape: ({tape_x}, {tape_y})", 
                       (tape_x + 10, tape_y - 10), cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255, 0, 0), 2)
            cv2.putText(display_frame, f"Angle: {tape_angle:.1f}¬∞", 
                       (tape_x + 10, tape_y + 10), cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255, 0, 0), 2)
            cv2.putText(display_frame, f"Area: {contour_info['area']:.0f}", 
                       (tape_x + 10, tape_y + 30), cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255, 0, 0), 2)
            
            # ÊòæÁ§∫Ê£ÄÊµãÁªìÊûú
            cv2.imshow('Automated Error Test - Press t to test, q to quit', display_frame)
            cv2.waitKey(1000)  # ÊòæÁ§∫1Áßí
            
            # ‰∫∫Â∑•Á°ÆËÆ§Ê£ÄÊµãÁªìÊûú
            confirm = input("Ê£ÄÊµãÂà∞ÁöÑÁ∫¢Ëâ≤ËÉ∂Â∏¶ÊòØÂê¶Ê≠£Á°ÆÔºü(y/n): ")
            if confirm.lower() == 'y':
                print("‚úÖ Áî®Êà∑Á°ÆËÆ§Ê£ÄÊµãÁªìÊûúÊ≠£Á°Æ")
                break
            elif attempt < max_attempts - 1:
                print("üîÑ ÈáçÊñ∞Ê£ÄÊµã...")
                tape_result = None  # ÈáçÁΩÆÊ£ÄÊµãÁªìÊûúÔºåÁ°Æ‰øù‰∏ãÊ¨°Âæ™ÁéØÈáçÊñ∞Ê£ÄÊµã
                continue
            else:
                print("‚ùå ËææÂà∞ÊúÄÂ§ßÂ∞ùËØïÊ¨°Êï∞ÔºåÊ£ÄÊµãÂ§±Ë¥•")
                return False
        
        # ËÆ°ÁÆóËÉ∂Â∏¶ÁöÑÁâ©ÁêÜÂùêÊ†á
        try:
            tape_physical_coord_2d = self.system.calibration.pixel_to_physical(tape_pixel_coord)
            if not tape_physical_coord_2d:
                print("‚ùå Êó†Ê≥ïËÆ°ÁÆóËÉ∂Â∏¶Áâ©ÁêÜÂùêÊ†á")
                return False
            # Ê∑ªÂä†ZÂùêÊ†áÔºà‰ΩøÁî®ÁõÆÊ†á‰ΩçÁΩÆÁöÑZÂùêÊ†áÔºâ
            tape_physical_coord = (tape_physical_coord_2d[0], tape_physical_coord_2d[1], target_coord[2])
        except ValueError as e:
            print(f"‚ùå Ê†áÂÆöÈîôËØØ: {e}")
            return False
        
        # Á¨¨ÂõõÊ≠•ÔºöËÆ°ÁÆóËØØÂ∑ÆÂπ∂Â≠òÂÇ®
        print("üìä Á¨¨ÂõõÊ≠•ÔºöËÆ°ÁÆóËØØÂ∑ÆÂπ∂Â≠òÂÇ®...")
        
        # ËÆ°ÁÆóËØØÂ∑ÆÔºàËÉ∂Â∏¶‰ΩçÁΩÆ - ÁõÆÊ†á‰ΩçÁΩÆÔºâ
        x_error = tape_physical_coord[0] - target_coord[0]
        y_error = tape_physical_coord[1] - target_coord[1]
        z_error = tape_physical_coord[2] - target_coord[2] if len(tape_physical_coord) > 2 else 0
        
        print(f"ÁõÆÊ†á‰ΩçÁΩÆ: {target_coord}")
        print(f"ÂÆûÈôÖ‰ΩçÁΩÆÔºàËÉ∂Â∏¶Ôºâ: {tape_physical_coord}")
        print(f"ËØØÂ∑Æ: ({x_error:.2f}, {y_error:.2f}, {z_error:.2f})")
        print(f"ÊÄªËØØÂ∑Æ: {np.sqrt(x_error**2 + y_error**2 + z_error**2):.2f} mm")
        
        # Ê∑ªÂä†ËØØÂ∑ÆÊï∞ÊçÆÂà∞Êï∞ÊçÆÂ∫ì
        RobotCompensation.add_error_data(target_coord, tape_physical_coord)
        self.system.robot.move_to_home()
        
        print("‚úÖ ËØØÂ∑ÆÊï∞ÊçÆÂ∑≤Ê∑ªÂä†Âà∞Êï∞ÊçÆÂ∫ì")
        
        # ÊòæÁ§∫ÂΩìÂâçÊï∞ÊçÆÂ∫ì‰ø°ÊÅØ
        info = RobotCompensation.get_database_info()
        print(f"Êï∞ÊçÆÂ∫ìÁé∞Âú®ÂåÖÂê´ {info['record_count']} Êù°ËÆ∞ÂΩï")
        
        return True

    def perform_camera_error_test(self, frame):
        """ÊâßË°åÊëÑÂÉèÂ§¥ËØØÂ∑ÆÊµãËØï"""
        print("\nüîç ÊâßË°åÊëÑÂÉèÂ§¥ËØØÂ∑ÆÊµãËØï...")
        
        # Ê£ÄÊü•Á≥ªÁªüÊòØÂê¶Â∑≤ÂàùÂßãÂåñ
        if not self.system:
            print("‚ùå Á≥ªÁªüÊú™ÂàùÂßãÂåñ")
            return False
        
        # Ê£ÄÊµãÁ∫¢Ëâ≤‰πêÈ´òÁßØÊú®
        result = self.system.detect_red_lego(frame)
        
        if not result:
            print("‚ùå Êú™Ê£ÄÊµãÂà∞Á∫¢Ëâ≤‰πêÈ´òÁßØÊú®")
            return False
        
        x, y, angle = result
        pixel_coord = (x, y)
        
        print(f"Ê£ÄÊµãÂà∞ÁßØÊú®‰ΩçÁΩÆ: {pixel_coord}")
        print(f"Ê£ÄÊµãÂà∞ÁßØÊú®ËßíÂ∫¶: {angle:.1f}¬∞")
        
        # ËÆ°ÁÆóÁâ©ÁêÜÂùêÊ†á
        if not self.system.calibration:
            print("‚ùå Á≥ªÁªüÊú™Ê†áÂÆö")
            return False
        
        try:
            physical_coord = self.system.calibration.pixel_to_physical(pixel_coord)
            if not physical_coord:
                print("‚ùå Êó†Ê≥ïËÆ°ÁÆóÁâ©ÁêÜÂùêÊ†á")
                return False
        except ValueError as e:
            print(f"‚ùå Ê†áÂÆöÈîôËØØ: {e}")
            print("ËØ∑ÂÖàËøêË°å‰∏ªÁ≥ªÁªüÂÆåÊàêÊâãÁúºÊ†áÂÆö")
            return False
        
        # Â∫îÁî®Âü∫Á°ÄË°•ÂÅø
        compensated_coord = self.system.calculate_grasp_position(pixel_coord)
        if not compensated_coord:
            print("‚ùå Êó†Ê≥ïËÆ°ÁÆóË°•ÂÅøÂêéÂùêÊ†á")
            return False
        
        print(f"ËÆ°ÁÆóÂæóÂà∞ÁõÆÊ†áÁâ©ÁêÜÂùêÊ†á: {physical_coord}")
        print(f"Â∫îÁî®Ë°•ÂÅøÂêéÂùêÊ†á: {compensated_coord}")
        
        # Á°ÆËÆ§ÁßªÂä®
        confirm = input("ÊòØÂê¶ËÆ©Êú∫Ê¢∞ËáÇÁßªÂä®Âà∞Ê£ÄÊµã‰ΩçÁΩÆÔºü(y/n): ")
        if confirm.lower() != 'y':
            print("‚ùå ÂèñÊ∂àÊµãËØï")
            return False
        
        # ËÆ©Êú∫Ê¢∞ËáÇÁßªÂä®Âà∞ÁõÆÊ†á‰ΩçÁΩÆ
        print("ÔøΩÔøΩ Êú∫Ê¢∞ËáÇÊ≠£Âú®ÁßªÂä®Âà∞ÁõÆÊ†á‰ΩçÁΩÆ...")
        
        try:
            # ‰ΩøÁî®Á≥ªÁªüÁöÑÊäìÂèñÂ∫èÂàóÔºà‰ΩÜ‰∏çÂÆûÈôÖÊäìÂèñÔºâ
            success = self.system.execute_grasp_sequence(compensated_coord, angle)
            if success:
                print("‚úÖ Êú∫Ê¢∞ËáÇÁßªÂä®ÂÆåÊàê")
            else:
                print("‚ùå Êú∫Ê¢∞ËáÇÁßªÂä®Â§±Ë¥•")
                return False
        except Exception as e:
            print(f"‚ùå Êú∫Ê¢∞ËáÇÁßªÂä®Â§±Ë¥•: {e}")
            return False
        
        # Á≠âÂæÖÁî®Êà∑ÊµãÈáèÂÆûÈôÖ‰ΩçÁΩÆ
        input("\nËØ∑ÊµãÈáèÊú∫Ê¢∞ËáÇÂÆûÈôÖÂà∞Ëææ‰ΩçÁΩÆÔºåÁÑ∂ÂêéÊåâÂõûËΩ¶ÁªßÁª≠...")
        
        # ËæìÂÖ•ÂÆûÈôÖ‰ΩçÁΩÆ
        try:
            print("\nËØ∑ËæìÂÖ•Êú∫Ê¢∞ËáÇÂÆûÈôÖÂà∞Ëææ‰ΩçÁΩÆ:")
            actual_x = float(input("ÂÆûÈôÖXÂùêÊ†á (mm): "))
            actual_y = float(input("ÂÆûÈôÖYÂùêÊ†á (mm): "))
            actual_z = float(input("ÂÆûÈôÖZÂùêÊ†á (mm): "))
            actual_position = (actual_x, actual_y, actual_z)
            
            # Ê∑ªÂä†ËØØÂ∑ÆÊï∞ÊçÆ
            RobotCompensation.add_error_data(compensated_coord, actual_position)
            
            # ËÆ°ÁÆóËØØÂ∑Æ
            x_error = actual_x - compensated_coord[0]
            y_error = actual_y - compensated_coord[1]
            z_error = actual_z - compensated_coord[2]
            
            print(f"\nüìä ËØØÂ∑ÆÂàÜÊûê:")
            print(f"ÁõÆÊ†á‰ΩçÁΩÆ: {compensated_coord}")
            print(f"ÂÆûÈôÖ‰ΩçÁΩÆ: {actual_position}")
            print(f"ËØØÂ∑Æ: ({x_error:.2f}, {y_error:.2f}, {z_error:.2f})")
            
            return True
            
        except ValueError:
            print("‚ùå ËæìÂÖ•Ê†ºÂºèÈîôËØØÔºåËØ∑ËæìÂÖ•Êï∞Â≠ó")
            return False
    
    def test_compensation_effect(self):
        """ÊµãËØïË°•ÂÅøÊïàÊûú"""
        print("\nüß™ ÊµãËØïË°•ÂÅøÊïàÊûú")
        print("=" * 50)
        
        if not RobotCompensation.ERROR_DATABASE:
            print("‚ùå Ê≤°ÊúâËØØÂ∑ÆÊï∞ÊçÆÔºåÊó†Ê≥ïÊµãËØïË°•ÂÅøÊïàÊûú")
            return False
        
        print("‚úÖ ÂèëÁé∞ËØØÂ∑ÆÊï∞ÊçÆÔºåÂºÄÂßãÊµãËØïË°•ÂÅøÊïàÊûú")
        
        # ÊòæÁ§∫Êï∞ÊçÆÂ∫ì‰ø°ÊÅØ
        info = RobotCompensation.get_database_info()
        print(f"Êï∞ÊçÆÂ∫ìÂåÖÂê´ {info['record_count']} Êù°ËÆ∞ÂΩï")
        
        # ÊµãËØïÂá†‰∏™‰ΩçÁΩÆ
        test_positions = [
            (0, 0, 25),
            (50, 50, 25),
            (-50, -50, 25)
        ]
        
        for position in test_positions:
            print(f"\nÊµãËØï‰ΩçÁΩÆ: {position}")
            
            # ‰º†ÁªüË°•ÂÅø
            traditional = RobotCompensation.apply_position_compensation(*position)
            print(f"‰º†ÁªüË°•ÂÅø: {traditional}")
            
            # Êï∞ÊçÆÂåñË°•ÂÅø
            data_driven = RobotCompensation.data_driven_position_compensation(*position)
            print(f"Êï∞ÊçÆÂåñË°•ÂÅø: {data_driven}")
            
            # ÊØîËæÉÂ∑ÆÂºÇ
            diff_x = data_driven[0] - traditional[0]
            diff_y = data_driven[1] - traditional[1]
            diff_z = data_driven[2] - traditional[2]
            print(f"Ë°•ÂÅøÂ∑ÆÂºÇ: ({diff_x:.2f}, {diff_y:.2f}, {diff_z:.2f})")
    
    def run_interactive_test(self):
        """ËøêË°å‰∫§‰∫íÂºèÊµãËØï"""
        print("üß™ ËØØÂ∑ÆË°•ÂÅø‰∫§‰∫íÂºèÊµãËØï")
        print("=" * 60)
        
        # ÂàùÂßãÂåñÁ≥ªÁªü
        if not self.initialize_system():
            return False
        
        # Âä†ËΩΩÁé∞ÊúâÊï∞ÊçÆÂ∫ì
        try:
            RobotCompensation.load_error_database()
        except:
            print("‚ö†Ô∏è Êú™ÊâæÂà∞Áé∞ÊúâÊï∞ÊçÆÂ∫ìÊñá‰ª∂ÔºåÂ∞ÜÂàõÂª∫Êñ∞ÁöÑÊï∞ÊçÆÂ∫ì")
        
        while True:
            print("\nËØ∑ÈÄâÊã©ÊµãËØïÈÄâÈ°π:")
            print("1. ÊâãÂä®ËØØÂ∑ÆÂΩïÂÖ•")
            print("2. ÊëÑÂÉèÂ§¥ËØØÂ∑ÆÊµãËØï (ÈúÄË¶ÅÂÖàËøõË°åÊâãÁúºÊ†áÂÆö)")
            print("3. Ëá™Âä®ÂåñËØØÂ∑ÆÊµãËØï (ÈúÄË¶ÅÂÖàËøõË°åÊâãÁúºÊ†áÂÆö)")
            print("4. ÊµãËØïË°•ÂÅøÊïàÊûú")
            print("5. Êü•ÁúãËØØÂ∑ÆÊï∞ÊçÆÂ∫ì")
            print("6. ‰øùÂ≠òÊï∞ÊçÆÂ∫ì")
            print("7. Âä†ËΩΩÊï∞ÊçÆÂ∫ì")
            print("8. ÈÄÄÂá∫")
            
            choice = input("ËØ∑ËæìÂÖ•ÈÄâÈ°π (1-8): ")
            
            if choice == '1':
                self.manual_error_test()
            elif choice == '2':
                self.camera_based_error_test()
            elif choice == '3':
                self.automated_error_test()
            elif choice == '4':
                self.test_compensation_effect()
            elif choice == '5':
                print("\nüìä ÂΩìÂâçËØØÂ∑ÆÊï∞ÊçÆÂ∫ì:")
                RobotCompensation.print_error_database()
            elif choice == '6':
                RobotCompensation.save_error_database()
            elif choice == '7':
                RobotCompensation.load_error_database()
            elif choice == '8':
                print("üëã ÈÄÄÂá∫ÊµãËØï")
                break
            else:
                print("‚ùå Êó†ÊïàÈÄâÈ°πÔºåËØ∑ÈáçÊñ∞ÈÄâÊã©")

def main():
    """‰∏ªÂáΩÊï∞"""
    tester = ErrorCompensationTester()
    tester.run_interactive_test()

if __name__ == "__main__":
    main()